---
title: "Overview of the 'demprep' Package"
output: rmarkdown::html_vignette
vignette: >
    %\VignetteIndexEntry{Overview of the 'demprep' Package}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
library(knitr)
library(demprep)
library(dplyr)
opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  echo = TRUE,
  fig.width = 6.5,
  fig.align = "center"
)
deaths <- data.frame(name = c("Anwar", "Baptiste", "Candice"),
                     date_birth = c("2014-02-17", "2012-01-10", "2019-04-29"),
                     date_death = c("2019-10-11", "2020-02-27", "2020-08-01"))

births_in <- data.frame(date_child = c("2020-05-18", "2020-07-02", "2020-10-05"),
                        date_parent = c("2000-02-14", "2002-05-18", "1990-12-18"))

births_out <- data.frame(date_child = c("2020-03-14", "2020-08-22"),
                         date_parent = c("1968-01-23", "2008-03-05"))
```

# Introduction

Demographic analyses typically work with data that has been arranged into tables like this:
```{r deaths-array, echo = FALSE}
deaths_array <- matrix(c(3, 0, 1, 5, 0, 2, 4, 0, 2),
                       nrow = 3, 
                       ncol = 3,
                       dimnames = list(age = c("0-4", "5-9", "10-14"),
                                       year = 2020:2022))
kable(deaths_array,
      align = "c",
      caption = "Counts of deaths by age group and year")
```
Events are categorised into age groups and periods. The age groups and periods have standardised widths, with standard labels.

raw demographic data from registration systems or surveys, however, typically comes in formats like this:
```{r deaths-raw, echo = FALSE}
deaths_raw <- data.frame(name = c("alice", "bilal", "clara", "djeneba", "ergi", "faisal"),
                               date_of_birth = c("2022-04-17", "2009-12-03", "2020-07-01",
     			                         "2011-11-29", "2020-05-16", "2018-03-30"),
			       date_of_death = c("2022-07-19", "2021-10-18", "2022-14-16",
     			                         "2022-08-07", "2020-06-03", "2020-01-13"))
kable(deaths_raw,
      caption = "deaths by date of birth and date of death")
```
the data consists of individual events, rather than counts. the events themselves are indexed by dates, rather than being assigned to age groups and periods. even when the data does not come in a completely raw form, it often looks something like this:
```{r deaths-semiclean, echo = FALSE}
deaths_semiclean <- data.frame(age = c("infant", "2 years", "12 years",
                                       "infants", "1 year"),
                               year = c(2020, 2020, 2020,
                                        2021, 2021),
                               count = c(2, 1, 1, 3, 2))
kable(deaths_semiclean,
      caption = "deaths by age group and year")
```
some age groups are missing from the data, and the labels for the age groups follow non-standard conventions.

getting from raw, or semi-raw, data to tabulations ready for demographic analysis can be harder than it looks. consider, for instance, a person born on 31 january 2001. on what date does that person become one month old? according base *r* function `seq.Date`, the answer is 3 march 2001:
```{r one-month}
seq.Date(from = as.Date("2001-01-31"), 
         by = "month",
         length.out = 2)
```

package **demprep** provides functions for processing demographic data to the point where the data is ready to be analysed using the other **dem** packages. **demprep** focuses in particular on the processing of information related to age and time, since this is usually the hardest part of preparing demographic data, and since *r* currently lacks tools for processing age and time information into standard demographic formats.

in this vignette, we start with some definitions and conventions, including the rules that **demprep** follows for measuring age and constructing labels. next we examine each of the main groups of functions. we then show how these functions can be used in practice, through two realistic case studies.  we conclude by describing how functions in **demprep** can be used alongside functions from base *r* and from other packages, when preparing demographic data.

# definining age groups, periods, cohorts, and lexis triangles

when describing individual people or events, we can use precise ages or times: this person is 11 years and 5 days old, or this event happened on 2 february 2021. but when describing groups of people or events, we use intervals: these people are between 10 and 15 years old, or these events occurred during the year 2021. 

one way to visualise intervals for age and time is through a lexis diagram. the figure below is an example. the horizontal axis measures calendar time, and the vertical axis measures age. the vertical lines mark out dates. the intervals between the dates in the diagram are periods. the period 2000-2015, for instance, starts on 2000-01-01 and ends just before 2005-01-01. similarly, the horizontal lines mark out exact ages, and the intervals between the exact ages are age groups. the age group 5-9, for instance, start with exact age 5, and ends just before exact age 10.

```{r agetime, echo = FALSE}
date <- as.Date(c("2020-12-07", "2022-05-30"))
dob <- as.Date(c("2001-07-22", "2006-03-14"))
age <- c(19 + 4.5/12, 16 + 2.5/12)
```


```{r lexis1, echo = FALSE, fig.width = 5, fig.height = 5, fig.cap = "A Lexis diagram"}
breaks_time <- seq.Date(from = as.Date("2000-01-01"),
                        to = as.Date("2025-01-01"), 
                        by = "5 years")
breaks_age <- seq.int(from = 0L, 
                      to = 25L, 
                      by = 5L)
year <- as.integer(format(breaks_time, "%Y"))
labels_time <- demprep:::make_labels_period_custom(year,
                                                   include_na = FALSE)
labels_age <- demprep:::make_labels_age(breaks = breaks_age,
                              open_last = FALSE,
                              include_na = FALSE)
demprep:::plot_date_to_age_triangle(date = date,
                                    dob = dob,
                                    unit = "year",
                                    breaks_time = breaks_time,
                                    breaks_age = breaks_age,
                                    labels_time = labels_time,
                                    labels_age = labels_age,
                                    show_vert = TRUE,
                                    show_diag = TRUE,
                                    show_months = FALSE)
text(x = date,
     y = age,
     labels = expression(italic(A), italic(B)),
     pos = 4)
```

A birth cohort is a group of people who were born during the same period. The diagonal lines in the Lexis diagram mark the borders between cohorts. In the Lexis diagram above, for instance, the birth cohort 2000-2005 starts at the bottom left of the diagram, and ends at the top left.

Cohorts can be defined by events other than birth. People marrying during the same decade form a type of cohort, for instance, as do people joining an organization during the same year. However, birth cohorts are the most common type of cohort, and when the term "cohort" is used without any sort of qualifier, it generally means "birth cohort".

The black dots $A$ and $B$ in the Lexis diagram represent deaths, and the black diagonal lines are "life lines" for the people experiencing these deaths. The two deaths belong to the same period (2020-2025) and age group (15-19). Death $A$, however, belongs to cohort 2000-2005, while death $B$ belongs to cohort 2005-2010. Period and age group do not, by themselves, contain enough information to unambiguously assign events to cohorts. 

To unambiguously assign events to cohorts, we need on additional piece of information: the Lexis triangle to which the event belongs. Lexis triangles are defined by combinations of the horizontal, vertical, and diagonal lines in Lexis diagrams. Event $A$, for example, belongs to the upper Lexis triangle for period 2020-2025 and age group 15-19, and event $B$ belongs to the lower Lexis triangle.  

Cohorts, and Lexis triangles require time steps and age steps to have equal sizes. In the Lexis diagram above, for instance, the time steps and age steps are both 5 years. However, demographic data does not always use the same size steps for age and time. The Lexis diagram beow, for instance, has 10-year time steps and 5-year age steps. 

```{r lexis2, echo = FALSE, fig.width = 5, fig.height = 5, fig.cap = "A Lexis diagram with time steps and age steps of different lengths"}
breaks_time <- seq.Date(from = as.Date("2000-01-01"),
                        to = as.Date("2030-01-01"), 
                        by = "10 years")
breaks_age <- seq.int(from = 0L, 
                      to = 25L, 
                      by = 5L)
year <- as.integer(format(breaks_time, "%Y"))
labels_time <- demprep:::make_labels_period_custom(year,
                                                   include_na = FALSE)
labels_age <- demprep:::make_labels_age(breaks = breaks_age,
                                        open_last = FALSE,
                                        include_na = FALSE)
demprep:::plot_date_to_age_triangle(date = date,
                                    dob = dob,
                                    unit = "year",
                                    breaks_time = breaks_time,
                                    breaks_age = breaks_age,
                                    labels_time = labels_time,
                                    labels_age = labels_age,
                                    show_vert = TRUE,
                                    show_diag = FALSE,
                                    show_months = FALSE)
text(x = date,
     y = age,
     labels = expression(italic(A), italic(B)),
     pos = 4)
```

- age and time use same length steps (subject to complications of months and years having different lengths, plus open age group)
- one month; one quarter; one year; $n$ years
- age and time not enough to identify cohort; also need Lexis triangle
- abstract: 
- event is in upper Lexis triangle

- An event occurring during period $t$ to a person in age group $a$ belongs to the lower Lexis triangle if the person attains age $a$ during, and to the upper Lexis triangle otherwise. (Covers youngest and oldest age groups.)


- If index of time equals index for age, then Lower; else Upper.

How to work out triangle:

1. Use date now and dob to calculate age group now
2. Use date now to identify date at start of period
3. Use date at start of period and dob to calculate whether entered age group during period
4. If so, lower; if not upper.





## How **demprep** measures age

In ordinary English, "age" means "age in completed years" or "age at last birthday". Demographers typically adopt this same rule when specifying ages in years. For instance, demographers describe as a person who was born 5 years and 57 days ago as "5 years old", and describe a person who was born 2 days ago as 0 years old.

Demographers extend the same rule to measuring age in months. Thus, for instance, demographers describe a person who was born 3 months as 23 days ago as "3 months old".

Some applications require describing ages in three-month units called "quarters". The age-in-completed-units approach can be applied to quarters. A person who was born 3 months and 23 days ago can be referred to as "1 quarter old".

Whether using years, months, or quarters, however, the measurement of age is complicated by the fact that some months are longer than others. April has 30 days, while May has 31, for instance, and February has 29 days in leap years and 28 days in non-leap years. The question of when a person born on 31 January 2001 turns 1 month old is difficult to answer because February is shorter than January. 

One approach to the problem of measuring ages with unequal months is to define new month-like units consisting of, say, 365/12 days, and use these instead. While this approach might be suitable for some purposes, it is unsuitable for most tasks in applied demography, where people want to know what has happened, or will happen, during conventionally-labelled months or years. Using artificial months that were 365/12 days long would mean that reaching three months of age always required experiencing three times as many days as reaching one month of age. However, because the new artificial months would not line up with standard months, any recording system based on these months would be unable to answer the questions that most users of demographic statistics were likely to ask. Users of monthly birth statistics want to know, for instance, how many births occurred during 1 June--30 June, for instance, not some artificial period of 365/12 days that approximately aligns with 1 June--30 June.

To obtain data that respects the boundaries between standard months and years, we need to incorporate these months and years into our calculations of variables such as age. In **demprep** we calculate age in months using the formula
\begin{equation}
\begin{split}
\text{age in completed months} & = 12 \times (\text{year of event} - \text{year of birth}) \\
& \quad + \text{month of event} - \text{month of birth} \\
& \quad - I\{\text{day of event} \ge \text{day of birth}\}.
\end{split}
\end{equation}
The $I\{\text{day of event} \ge \text{day of birth}\}$ translates as "1 if the day of event is greater than or equal to day of birth, and 0 otherwise".

Consider, for instance, a person born on 2 January 2020 who emigrates on 13 March 2030. We calculate the age of the person at the time of the emigration as follows:
\begin{align} 
  \text{age in completed months} & = 12 \times (2030 - 2020) + (3 - 1) + 1 \\
                                 & = 123.
\end{align}

Using this approach a child who was born in 31 January 2001 is 0 months old on 28 February, and 1 month old on 1 March. The approach therefore implies that the child turns one month old on 1 March, which is a different answer from the one implied by function `seq.Date`.

Age in completed years can be obtained by dividing age in completed months by 12, and discarding any remainder. If a person is aged 123 in completed months, then the person is aged 10 in completed years. (The corresponding *R* operation is integer division, obtained through the `%/%` operator.)

Similarly, age in completed quarters can be obtained by dividing age in completed months by 3 and dividing any remainder. If a person is aged 123 in completed months, then that person is aged 41 in completed quaters.




```{r, echo = FALSE, fig.height = 6.5}
date <- c("2021-03-30", "2021-03-10")
dob <- c("2021-01-30", "2021-01-10")
demprep:::plot_date_to_age_month(date = date,
                                 dob = dob)
```


# **demprep** labels for age groups, periods, and cohorts

The conventions that **demprep** uses for labelling age groups, periods, and cohorts are summarised in the following table.


Table: Examples of **demprep** labels for age groups, periods, and cohorts

| Unit  | Type   | Age group | Period     | Cohort       |
|:------|:-------|:----------|:-----------|:-------------|
| year  | single | `"0"`     | `"2020"`   | `"2020"`     |
| year  | multiple |  `"5-9"` | `"2025-2030"` | `"2025-2030"` |
| year  | open left |  |  | `"<2020"` |
| year  | open right | `"100+"` |  |  |
| quarter | single | `"12"` | `"2020 Q1"` | `"2020 Q1"` |
| quarter  | multiple |  |  |  |
| quarter | open left |  |  | `"<2020 Q1"` |
| quarter | open right | `"12+"` |  |  |
| month | single | `"12"` | `"2020 Q1"` | `"2020 Q1"` |
| month  | multiple |  |  |  |
| month | open left |  |  | `"<2020 Jan"` |
| month | open right | `"36+"` |  |  |


Choosing appropriate labels for age groups, periods, and cohorts is non-trivial. Demographers have never developed a universally-accepted set of labelling conventions. Moreover, the conventions that do exist lead to labels that are ambiguous.

Labels for age groups pose the fewest problems. When an age group extends over more than one year, demographers almost always use labels such as "20-24", which includes anyone whose age in completed years is 20, 21, 22, 23 or 24. When referring to a mix of single-year and multiple-year age groups, demographers use a mix of single-year and multiple-year labels, as in "0, 1-4, 5-9, 10-14". When 







Table: Intervals that the period or cohort label "2020" can refer to

| Label uses start year | Label uses end year   |
|:----------------------:|:----------------------:|
| 1 Jan 2020 - 31 Dec 2020 | 1 Feb 2019 - 31 Jan 2020 |
| 1 Feb 2020 - 31 Jan 2021 | 1 Mar 2019 - 29 Feb 2020 |
| 1 Mar 2020 - 28 Feb 2021 | 1 Apr 2019 - 31 Mar 2020 |
| 1 Apr 2020 - 31 Mar 2021 | 1 May 2019 - 30 Apr 2020 |
| 1 May 2020 - 30 Apr 2021 | 1 Jun 2019 - 31 May 2020 |
| 1 Jun 2020 - 31 May 2021 | 1 Jul 2019 - 30 Jun 2020 |
| 1 Jul 2020 - 30 Jun 2021 | 1 Aug 2019 - 31 Jul 2020 |
| 1 Aug 2020 - 31 Jul 2021 | 1 Sep 2019 - 31 Aug 2020 |
| 1 Sep 2020 - 31 Aug 2021 | 1 Oct 2019 - 30 Sep 2020 |
| 1 Oct 2020 - 30 Sep 2021 | 1 Nov 2019 - 31 Oct 2020 |
| 1 Dec 2020 - 30 Nov 2021 | 1 Dec 2019 - 30 Nov 2020 |





# Calculating ages, periods, cohorts, and Lexis diagrams from data on dates

Suppose that we have some raw data on dates of birth and dates of enrolment in a health care scheme:

```{r, echo = FALSE}
dates_df <- data.frame(date_of_birth = c("2000-03-07", "2010-12-25", "2007-02-28"),
                       date_of_enrolment = c("2002-08-12", "2014-01-31", "2015-07-01"))
dates_df		       
```

Suppose also that we want to calculate people's age at the time they enrolled, and the quarters in which they enrolled.

```{r, echo = FALSE}
dates_df %>%
  mutate(age = date_to_age_year(date = date_of_enrolment, dob = date_of_birth),
         quarter = date_to_period_quarter(date = date_of_enrolment))
```

We can do these calculations, and others like them, using the `date_to` functions in **demprep**.


| Age groups            | Periods                  | Cohorts                  | Lexis triangles            |
| :-----------          | :----------------------- | :--------                | :------------------------- |
| `date_to_age_year`    | `date_to_period_year`    | `date_to_cohort_year`    | `date_to_triangle_year`    |
| `date_to_age_quarter` | `date_to_period_quarter` | `date_to_cohort_quarter` | `date_to_triangle_quarter` |
| `date_to_age_month`   | `date_to_period_month`   | `date_to_cohort_month`   | `date_to_triangle_month`   |

The `year`, `quarter`, and `month` suffixes in the function names describe the measurement units, so that, for example, `date_to_age_month` return's people's ages in months, and `date_to_cohort_year` returns people's year of birth.

To demonstrate the use of the `date_to` functions, we will be using the data frame `deaths`:

```{r}
deaths
```

Before proceeding, we need to load packages **demprep** and (for the pipe `%>%` and for functions `mutate` and `select`) **dplyr**.

```{r}
library(demprep)
library(dplyr)
```

## Age

The `date_to_age` functions calculate ages denominated in years, quarters, and months.

```{r}
deaths %>%
  mutate(age_years = date_to_age_year(date = date_death,
                                      dob = date_birth),
         age_quarters = date_to_age_quarter(date = date_death,
                                            dob = date_birth),
         age_months = date_to_age_month(date = date_death,
                                        dob = date_birth))
```

The calculations are done using the formulas discussed above, which are based on years, months, and days-within-months attained, rather than on absolute durations. Thus for example, a person born on 31 January 2001 turns one month old 29 days later,

```{r}
born_31_jan_01 <- data.frame(date_measure_age = c("2001-02-28", "2001-03-01"),
                             date_birth = c("2001-01-31", "2001-01-31"))
born_31_jan_01 %>%
  mutate(age_months = date_to_age_month(date = date_measure_age,
                                        dob = date_birth))
as.Date("2001-03-01") - as.Date("2001-01-31")					
```
while a person born on 31 January 2000 turns one month old 30 days later,
```{r}
born_31_jan_00 <- data.frame(date_measure_age = c("2000-02-29", "2000-03-01"),
                             date_birth = c("2000-01-31", "2000-01-31"))
born_31_jan_00 %>%
  mutate(age_months = date_to_age_month(date = date_measure_age,
                                        dob = date_birth))
as.Date("2000-03-01") - as.Date("2000-01-31")					
```
and a person born on 1 March 2001 turns one month old 31 days later,
```{r}
born_01_mar_01 <- data.frame(date_measure_age = c("2001-03-31", "2001-04-01"),
                             date_birth = c("2001-03-01", "2001-03-01"))
born_01_mar_01 %>%
  mutate(age_months = date_to_age_month(date = date_measure_age,
                                        dob = date_birth))
as.Date("2001-04-01") - as.Date("2001-03-01")					
```


## Periods

By default, `date_to_period_year` creates periods that start on 1 January,
```{r}
deaths %>%
  select(-date_birth) %>%
  mutate(year_start_jan = date_to_period_year(date = date_death))
```
that look something like this
```{r, echo = FALSE, fig.height = 1.75}
demprep:::plot_date_to_period_year(date = deaths$date_death)
```

However, other start date are possible, provided that date is the first of the month,
```{r}
deaths %>%
  select(-date_birth) %>%
  mutate(year_start_apr = date_to_period_year(date = date_death,
	                                            month_start = "Apr"))
```
```{r, echo = FALSE, fig.height = 1.75}
demprep:::plot_date_to_period_year(date = deaths$date_death,
                                   month_start = "Apr")
```

By default, `date_to_period_year` labels years according to the calendar year of the first day of the period. However, when `label_year_start` to `FALSE`,
`date_to_period_year` uses the last day of the period.
```{r}
deaths %>%
  select(-date_birth) %>%
  mutate(year_label_start = date_to_period_year(date = date_death,
                                                month_start = "Apr"),
         year_label_end = date_to_period_year(date = date_death,
                                              month_start = "Apr",
                                              label_year_start = FALSE))
```

Function `date_to_period_quarter`, in contrast, implements a single set of start dates (1 January, 1 April, 1 July, and 1 October), and implements a single labelling style.
```{r}
deaths %>%
  select(-date_birth) %>%
  mutate(quarter = date_to_period_quarter(date_death))
```

Function `date_to_period_month` is similarly simple/inflexible.
```{r}
deaths %>%
  select(-date_birth) %>%
  mutate(month = date_to_period_month(date_death))
```


## Cohorts

The `date_to_cohort` functions behave exactly like their `date_to_period` equivalents. For birth cohorts, we set `date` equal to date of birth.
```{r}
deaths %>%
  select(-date_death) %>%
  mutate(cohort = date_to_cohort_year(date = date_birth,
                                      month_start = "Apr",
                                      label_year_start = FALSE))
```

```{r, echo = FALSE, fig.height = 1.75}
demprep:::plot_date_to_cohort_year(date = deaths$date_birth)
```



## Lexis triangles

The `date_to_triangle` functions all have `date` and `dob` arguments. 
```{r}
deaths %>%
  mutate(triangle = date_to_triangle_year(date = date_death,
	                                  dob = date_birth))
```
```{r, echo = FALSE, fig.height = 6.5}
demprep:::plot_date_to_triangle_year(date = deaths$date_death,
                                     dob = deaths$date_birth)
```

Like `date_to_period_year`, and `date_to_cohort_year`, function `date_to_triangle_year` also has a `month_start` argument, which shifts the start date of the triangles.
```{r}
deaths %>%
  mutate(triangle = date_to_triangle_year(date = date_death,
	                                  dob = date_birth,
			                  month_start = "Jul"))
```
```{r, echo = FALSE, fig.height = 6.5}
demprep:::plot_date_to_triangle_year(date = deaths$date_death,
                                     dob = deaths$date_birth,
				     month_start = "Jul")
```

# Imputing dates

Sometimes input data has incomplete data on dates, such as having the year and month of births but not the days. One way of dealing with incomplete data is to impute the missing information. This is what functions `impute_date` and `impute_dob` are for.

The imputation is random, so, for repeatability, we set the random seed. 
```{r}
set.seed(0)
```

In our first example, we know the year and month of some events, but not the day, so we use `impute date`.
```{r}
impute_date(year = c(2000, 2005, 2003),
            month = c("Feb", "Nov", "Apr"))
```

In our second example, we know the dates of events, and we know people's age in years at the time of the eevents, and we want to impute dates of birth.
```{r}
impute_dob(date = c("2021-03-23", "2021-02-13", "2020-04-25"),
           age_years = c(3, 1, 0))
```


# Converting existing labels to **dem** formats

Published demographic demographic is usually already aggregated into age groups, periods, or cohorts, rather than giving the original dates of events. In this case, when preparing data for use in the **dem** packages, the first task is to edit the labels for the age groups, periods, cohorts, so that they follow **dem** convetions. The functions for editing existing labels, and for checking these edits, are as follows:


| Age groups     | Periods           | Cohorts           | 
| :-----------   | :--------         | :--------         | 
| `clean_age`    | `clean_period`    | `clean_cohort`    | 
| `clean_age_df` | `clean_period_df` | `clean_cohort_df` | 
| `is_valid_age` | `is_vald_period`  | `is_valid_cohort` |

Functions `clean_age`, `clean_period`, and `clean_cohort` try to parse vectors of labels and convert the labels, where necessary, into **dem** formats. If they cannot parse a label, or if a label is already valid, then the functions leave the label untouched.


```{r}
x <- c("20 years", "80 and over", "young", "20-24")
clean_age(x)
```

Function `clean_age` treats labels consisting entirely of multiples of 5 specially,
```{r}
x <- seq(0, 60, 5)
x
clean_age(x)
```
And also labels that look like they come from a life table,
```{r}
x <- c(0, 1, seq(5, 80, 5))
x
clean_age(x)
```


Functions `clean_cohort` and `clean_period` give identical results, except for intervals that are open on the left, which `clean_cohort` parses and `clean_period` does not.

```{r}
x <- c("Q1 2020", "1922", "2010-2025", "before 2020")
clean_cohort(x)
clean_period(x)
```

It can sometimes be helpful to see what `clean_age`, `clean_period`, and `clean_cohort` have done, or will do. This is the purpose of functions `clean_age_df`, `clean_period_df`, and `clean_cohort_df`.

```{r}
x <- c("2021", "2022-2025", "2021", "q2 2020")
clean_period_df(x)
```

It can also be helpful to be able to check whether `clean_age`, `clean_period`, and `clean_cohort` have been able to parse the entire vector. This is what functions `is_valid_age`, `is_valid_period`, and `is_valid_cohort` do.

```{r}
x <- c("2021", "the 1960s", "1960-1970")
is_valid_period(x)
```
In a production system, some version of
```{r, eval = FALSE}
stopifnot(all(is_valid_period(x)))
```
is useful to catch any unexpected inputs.


# Standardising and interpolating labels

## Overview

Demographic analyses usually require data to be arranged into age groups, periods, or cohorts, of standardised lengths, with all intermediate categories included. Tabulations should look like this

|   Age | 2020-2025 | 2025-2030 |
|-------+-----------+-----------|
|   0-4 |         1 |         3 |
|   5-9 |         4 |         8 |
| 10-14 |         0 |         3 |

rather than this

|   Age | 2020 | 2022-2023 | 2025-2030 |
|-------+------+-----------+-----------|
|   0-2 |    1 |         0 |         2 |
|     4 |    0 |         0 |         1 |
|   5-8 |    1 |         3 |         8 |
| 10-12 |    0 |         0 |         2 |
|    14 |    0 |         0 |         1 |.

The `format` functions take vectors of age, period, cohort, and Lexis triangle labels that conform to **dem** package conventions, and return factors where the intervals have standardised lengths, and where all intermediate categories, including ones that do not appear in the data, are included.

| Age groups           | Periods                 | Cohorts                 | Lexis triangles           |
| :-----------         | :--------               | :--------               | :----------------         |
| `format_age_year`    | `format_period_year`    | `format_cohort_year`    | `format_triangle_year`    |
| `format_age_multi`   | `format_period_multi`   | `format_cohort_multi`   | `format_triangle_multi`   |
| `format_age_custom`  | `format_period_custom`  | `format_cohort_custom`  | \<none\>                  |
| `format_age_lifetab` | \<none\>                | \<none\>                | \<none\>                  |
| `format_age_births`  | \<none\>                | \<none\>                | `format_triangle_births`  |
| `format_age_quarter` | `format_period_quarter` | `format_cohort_quarter` | `format_triangle_quarter` |
| `format_age_month`   | `format_period_month`   | `format_cohort_month`   | `format_triangle_month`   |

The last part of the function names describe the units that are returned. Functions `format_age_year`, `format_age_quarter`, and `format_age_month`, for instance, create labels where the intervals have lengths of one year, one quarter, and one month. Functions ending in `multi` return labels where then intervals can span multiple years, provided that the intervals all have the same length. Function `format_period_multi` can be used, for instance, to create labels for periods with widths of 5 years. `Functions ending in `custom` also  return labels where the intervals can span multiple years, but the intervals do not all have to be the same length. Function `format_age_lifetab` deals with age groups used in life tables, and  function `format_age_births` deals with age groups used for describing births.

When, for example, `format_age_multi` is supplied with a vector that uses single years of age, by default it converts these into 5-year age group labels: 
```{r}
original <- c(11, 93, 15, 30)
reformatted <- format_age_multi(original)
reformatted
```
The object holding the new 5-year labels is a factor. 
```{r}
class(reformatted)
```
A factor contain a "levels" attribute that lists all possible labels.
```{r}
levels(reformatted)
```
Tabulation functions such as `table`, `xtabs`, or `dtabs` (described below) make use of the levels.
```{r}
table(reformatted)
```
The tabulations include counts for all levels, including ones that do not appear in the data, which receive counts of zero. Including all levels is normally what we want when we are tabulating data for demographic analyses.

If we convert the factor into a character vector, the special behaviour is lost.
```{r}
table(as.character(reformatted))
```

Most of the `format` functions provide some control over the range of the labels. With `format_age_multi`, for instance, we can specify that the first age group starts at 10 rather than 0,
```{r}
format_age_multi(original, break_min = 10)
```

The `format` functions work on labels as well as numbers,
```{r}
x <- c("2020-2021", "2018", "2020-2025", "<2015")
format_cohort_multi(x)
```


## Age groups

Arguments `break_min`, `break_max`, and `open_last` can be used to control lower and upper limits of the age group labels. The default behavior for `format_age_year` and `format_age_multi`, for instance, is to create ordinary age groups between ages 0 and 100, and an open age group after that,
```{r}
x <- c("35-38", "50-54", "77")
format_age_multi(x, width = 10)
```
Alternative lower and upper limits can be specified via the `break_min` and `break_max` arguments,
```{r}
x <- c("35-38", "50-54", "77")
format_age_multi(x,
                 width = 10,
		 break_min = 20,
		 break_max = 90)
```
The open interval can be removed using the 'open_last' argument,
```{r}
x <- c("35-38", "50-54", "77")
format_age_multi(x,
                 width = 10,
		 break_min = 20,
		 break_max = 90,
		 open_last = FALSE)
```
Setting `break_min` and `break_max` to `NULL` allows the limits to be set by the data.
```{r}
x <- c("35-38", "50-54", "77")
format_age_multi(x,
                 width = 10,
		 break_min = NULL,
		 break_max = NULL)
```

When age groups with variable lengths are needed, function `format_age_custom` can be used. The age groups are defined via the `breaks` argument
```{r}
x <- c("35-38", "50-54", "77")
format_age_custom(x, breaks = c(15, 40, 80))
```

Function `format_age_lifetab` creates the special age groups needed for an "abridged" life table (ie a life table with age groups `"0"`, `"1-4"`, `"5-9"`, `"10-14"`, `"15-19"`, etc.
```{r}
x <- c("35-38", "50-54", "77")
format_age_lifetab(x)
```

The other specialsed `format_age` function is `format_age_biths`, which creates age groups for birth rates or counts,
```{r}
x <- c("22", "30-33", "18", "40-44")
format_age_births(x)
```
Function `format_age_biths` can recode values that fall outside the expected range,
```{r}
x <- c("10", "30-33")
format_age_births(x, recode_up = TRUE)
```

## Periods

The `format_period` functions, in contrast to the `format_age` functions do not have `break_min` and `break_max` arguments. Instead, the range of the labels is set by the data (like what happens with the `format_age` functions when `break_min` and `break_max` are set to `NULL`.)

The ambiguities of single-year period labels mean that functions `format_period_multi` and `format_period_custom` need extra information to parse these labels and align them to other labels. By default, `format_period_multi` and `format_period_custom` treats single-year periods as beginning in January. Under the default settings, the label `"2050"` refers to the period between 1 January 2050 and 31 December 2050, the label `"2050-2055"` refers the period between 1 January 2050 and 31 December 2054, and the first period falls within the second.
```{r}
x <- c("2050", "2050-2055")
format_period_multi(x)
```
However, if we set `month_start` to `"July"' and `label_year_start` to `FALSE`, then `"2050"` refers to the period between 1 July 2049 and 30 June 2050,  `"2050-2055"` refers to the period between 1 July 2050 and 31 June 2055, and the first period falls outside the second.
```{r}
x <- c("2050", "2050-2055")
format_period_multi(x,
                    month_start = "July",
		    label_year_start = FALSE)
```

Multi-year periods that start on, say, 2021 rather than 2020, can be obtained by changing the `origin` argument from its default value of 2000. The absolute value of `origin` does not in fact matter - only the remainder when it is divided by `width`.

```{r}
x <- c("2020", "2021", "2027-2028")
format_period_multi(x)
format_period_multi(x, origin = 2021)
```


## Cohorts

The `format_cohort` functions work exactly like the equivalent `format_period` functions, except that the `format_cohort` functions allow for the possibility of an interval that is open on the left.
```{r}
x <- c("2003", "1998", "2015", "1984", "2002")
format_cohort_year(x)
format_cohort_year(x, break_min = 1990)
```
A birth cohort with no lower limit is equivalent to an age group with no upper limit. On 31 December 2019, for instance, the cohort `"<1920" is equivalent to the age group 100+. 


## Lexis triangles

The `format_triangle` functions produce Lexis triangles that have consistent lengths. To aggregate triangles, the `format_triangle` functions need information on age, and, in the case of `format_triangle_multi` and `format_triangle_births`, detailed information on periods.
```{r}
x <- c("Lower", "Upper", "Lower")
age <- c("22", "56", "103")
format_triangle_year(x = x, age = age)
```


# Converting to labels that use explicit dates

The ambiguities of period and cohort labels do not normally cause any problems when working with a single dataset. When working with multiple datasets, however, aligning periods correctly can be confusing and error-prone.

The functions

|                    |
|--------------------|
| `as_date_range_year` |
| `as_date_range_multi` |
| `as_date_range_custom` |
| `as_date_range_quarter` |
| `as_date_range_month` |

convert from standared period and cohort labels to nonstandard but unambiguous ones that use explicit dates.

By default, `month_start` is set to `"Jan"` and `label_year_start` is set to `TRUE`
```{r}
x <- c("2022", "2028")
as_date_range_year(x)
```
Different settings give different interpretations of the same labels,
```{r}
x <- c("2022", "2028")
as_date_range_year(x, 
                   month_start = "Mar",
                   label_year_start = FALSE)
```



# Tabulation

Once all the variables have been put into the required formats, we can tabulate the data. The nicest tabulation function in base **R** is `xtabs`. **demprep** has a simpler alternative to `xtabs` called `dtabs`, designed specifically for constructing arrays of demgoraphic data. The differences between `xtabs` and `dtabs` are 

|                             | `xtabs`     | `dtabs`     |
|-----------------------------+-------------+-------------|
| Position of `data` argument | first       | second      |
| Treatment of `NA`           | complicated | extra level |
| Has `subset` argument       | yes         | no          |
| Drop unused levels          | sometimes   | never       |

For convenience when using the pipe, `dtabs` puts the `data` argument first.

Whereas `xtabs` has several different options for dealing with `NA`s in the data, `dtabs` always includes `NA` as a separate level. The idea is that the `NA`s should be made as visible as possible, so that the user needs to explicitly exclude them, or deal with them through some sort of imputation process. 

`xtabs` allows the user to take subsets of the data, or drop unused levels from factors, as part of the tabulation. `dtabs` does not have these options, so that users are forced to make separate calls to functions such as `subset` or `droplevels`. This is less concise, but clearer.

One thing that `dtabs` has in common with `xtabs`, however, is that it is designed for unweighted data, such as data from a census or an administrative census. It is not desgined for 


# Typical workflows


# Examples


# Relationship to other packages

**lubridate**, **zoo**


**tsibble**

**survey** more sophisticated treatment of weighted data.