---
title: "Preparing demographic data with the demprep package"
author: John Bryant, Bayesian Demography Limited
affiliation: Bayesian Demography Limited
date: '`r format(Sys.time(), "%e %B %Y")`'
output: 
  rmarkdown::html_vignette:
    number_sections: true
    toc: true
vignette: >
    %\VignetteIndexEntry{Preparing demographic data with the demprep package}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
library(knitr)
library(demprep)
library(dplyr)
opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  echo = TRUE,
  fig.width = 6.5,
  fig.align = "center"
)

births_in <- data.frame(date_child = c("2020-05-18", "2020-07-02", "2020-10-05"),
                        date_parent = c("2000-02-14", "2002-05-18", "1990-12-18"))

births_out <- data.frame(date_child = c("2020-03-14", "2020-08-22"),
                         date_parent = c("1968-01-23", "2008-03-05"))
```

# Introduction

Demographic analyses typically work with tabular data that uses standardized age groups and periods, like this:
```{r deaths-array, echo = FALSE}
deaths_array <- matrix(c(3, 0, 1, 5, 0, 2, 4, 0, 2),
                       nrow = 3, 
                       ncol = 3,
                       dimnames = list(age = c("0-4", "5-9", "10-14"),
                                       year = 2020:2022))
kable(deaths_array,
      align = "c",
      caption = "Counts of deaths by age group and year")
```

Raw data from registration systems or surveys, however, typically consists of individual events, rather than counts, and the events themselves are attached to dates rather than age groups or periods:
```{r deaths-raw, echo = FALSE}
deaths_raw <- data.frame(name = c("Alice", "Bilal", "Clara", "Djeneba", "Ergi", "Faisal"),
                               date_of_birth = c("2022-04-17", "2009-12-03", "2020-07-01",
     			                         "2011-11-29", "2020-05-16", "2018-03-30"),
			       date_of_death = c("2022-07-19", "2021-10-18", "2022-14-16",
     			                         "2022-08-07", "2020-06-03", "2020-01-13"))
kable(deaths_raw,
      caption = "Deaths by date of birth and date of death")
```
 
Even with processed data, the age groups or periods may not have the format we want, or may contain gaps:
```{r deaths-semiclean, echo = FALSE}
deaths_semiclean <- data.frame(age = c("Infant", "2 years", "12 years",
                                       "Infants", "1 year"),
                               year = c(2017, 2020, 2020,
                                        2021, 2021),
                               count = c(2, 1, 1, 3, 2))
kable(deaths_semiclean,
      caption = "Counts of deaths by age group and year")
```

Getting from raw, or semi-raw, data to tabulations ready for demographic analysis can be harder than it looks. When, for instance, does a person who was born on 31 January 2001 turn one month old? According to the base R function `seq.Date`, the answer is 3 March 2001:
```{r one-month}
seq.Date(from = as.Date("2001-01-31"), 
         by = "month",
         length.out = 2)
```

Package **demprep** provides functions for processing demographic data to the point where it is ready for analysis. **demprep** focuses in particular on getting data into the desired age-period-cohort format, since this is typically the hardest part of preparing demographic data. **demprep** is designed to work with the other **dem** packages (which are still being written) but can be used on its own.

# Background

## Calculating age

In demography, as in ordinary English, "age" normally means "age in completed years".  For instance, demographers describe a person who was born 5 years and 57 days ago as "5 years old". If, instead of years, demographers are using moths, then age means age in completed months. Demographers describe a person who was born 3 months and 23 days ago as "3 months old".

The measurement of age is, however, complicated by the fact that some the measurement units have different lengths. Leap years are one day longer than non-leap years, for instance, and May has one more day than April.

The approach used in **demprep** is to say that a person gains a extra month of age each time that the person reaches the day-of-the-month that they were born. If a person was born on 5 March 2000, for instance, then the person turns one month old on 5 April 2000, turns 2 months old on May 2000, turns 12 months old on 5 March 2001, and so on. A peron gain an extra year of age each time the person reaches the month and day-of-the-month that they were born.

What if the day-of-the-month that a person was born does not occur in the month in question? When, for instance, does the person who was born on 31 January 2000 turn one month old, given that February does not contain a 31st day? We adopt the rule that if the day-of-the-month on which a person was born does not occur in the month in question, then the person attains the extra month of age on the first day of the next month. We say, for instance, that a person born on 31 January attains the age of one month on 1 March. 

This approach to calculating age can be expressed as
\begin{equation}
\begin{split}
\text{age in completed months} & = 12 \times (\text{year of event} - \text{year of birth}) \\
& \quad + \text{month of event} - \text{month of birth} \\
& \quad - I\{\text{day of event} \ge \text{day of birth}\},
\end{split}
\end{equation}
whre the $I\{\text{day of event} \ge \text{day of birth}\}$ means "1 if the day of event is greater than or equal to day of birth, and 0 otherwise".

Age in completed years can be obtained by dividing age in completed months by 12, and discarding any remainder. If a person is aged 123 in completed months, then the person is aged 10 in completed years.

The **demprep** approach to calculating age sacrifices some uniformity, in that the same age measured in months can correspond to different ages measured in days, depending on the time of year. However, it has the more important virtue that it gives intuitive results when applied to typical problems in applied demography. It means, for instance, that a group of people who are aged $x$ months on 1 February are aged $x+1$ months on 1 March, and $x+2$ months on 1 April. Consistency between calendar time and age is helpful when calculating rates, or when linking changes in population to births, deaths, and migrations.


## Definining age groups, periods, cohorts, and Lexis triangles

An age group is ages that falls within a specified interval: the age group "10-14" years for instance, 10-year-olds, 11-year-olds, 12-year-olds, 13-year-olds, and 14-year-olds. A period is any date that falls within an interval: the period "2020-2030" for instance, typically means any date from 1 January 2020 to 31 December 2030.

A cohort is slightly more abstract: it is everyone who experienced a particular event during the specified period. The particular event is almost always births, so that a cohort is everyone born during the 1960s, for instance, or everyone born in 2007. However, cohorts can also be defined by other events, such as everyone who married during a particular decade, or everyone who started at an organization during a particular year.

Lexis triangles are less commonly encountered than age groups, periods, and cohorts, but are useful in problems that require switching between periods and cohorts. Lexis triangles can be defined through a Lexis diagram such as the figure below. The horizontal axis in the figure measures calendar time, and the vertical axis measures age. The horizontal grid lines mark out age groups, the vertical grid lines mark out periods, and the diagonal grid lines mark out cohorts. Lexis triangles are the triangles formed by the combination of the horizontal, vertical, and diagonal grid lines. Within each square, the triangle below the diagonal line is referred to as the lower Lexis triangle, and the triangle above the diagonal line is referred to as the upper Lexis triangle.

```{r agetime, echo = FALSE}
date <- as.Date(c("2020-12-07", "2022-05-30"))
dob <- as.Date(c("2001-07-22", "2006-03-14"))
age <- c(19 + 4.5/12, 16 + 2.5/12)
```


```{r lexis1, echo = FALSE, fig.width = 5, fig.height = 5, fig.cap = "A Lexis diagram"}
breaks_time <- seq.Date(from = as.Date("2000-01-01"),
                        to = as.Date("2025-01-01"), 
                        by = "5 years")
breaks_age <- seq.int(from = 0L, 
                      to = 25L, 
                      by = 5L)
year <- as.integer(format(breaks_time, "%Y"))
labels_time <- demprep:::make_labels_period_custom(year,
                                                   include_na = FALSE)
labels_age <- demprep:::make_labels_age(breaks = breaks_age,
                              open_last = FALSE,
                              include_na = FALSE)
demprep:::plot_date_to_age_triangle(date = date,
                                    dob = dob,
                                    unit = "year",
                                    breaks_time = breaks_time,
                                    breaks_age = breaks_age,
                                    labels_time = labels_time,
                                    labels_age = labels_age,
                                    show_vert = TRUE,
                                    show_diag = TRUE,
                                    show_months = FALSE)
text(x = date,
     y = age,
     labels = expression(italic(A), italic(B)),
     pos = 4)
```

Lexis triangles provide the extra information needed to distinguish between cohorts when dealing with events that are categorised by age group and period. Consider, for instance, the black dots $A$ and $B$ in the diagram above. The dots represent deaths, and the black diagonal lines are "life lines" for the people experiencing these deaths. The two deaths belong to the same period (2020-2025) and the same age group (15-19). The deaths do not, however, belong to the same cohort: death $A$, however, belongs to cohort 2000-2005, while death $B$ belongs to cohort 2005-2010. Knowing the period and age group for deaths $A$ and $B$ is not enough, on its own, to assign each death to a cohort. If, however, we also know that death $A$ belongs to the upper Lexis triangle, and death $B$ belongs to the lower Lexis triangle, then we can assign the deaths to cohorts.

Cohorts and Lexis triangles require time steps and age steps to have equal sizes. In the Lexis diagram above, for instance, the time steps and age steps are both 5 years. Demographic data does not always use the same size steps for age and time. The Lexis diagram beow, for instance, has 10-year time steps and 5-year age steps. When time steps and age steps are different lengths, defining cohorts and Lexis triangles is difficult.

```{r lexis2, echo = FALSE, fig.width = 5, fig.height = 5, fig.cap = "A Lexis diagram with time steps and age steps of different lengths"}
breaks_time <- seq.Date(from = as.Date("2000-01-01"),
                        to = as.Date("2030-01-01"), 
                        by = "10 years")
breaks_age <- seq.int(from = 0L, 
                      to = 25L, 
                      by = 5L)
year <- as.integer(format(breaks_time, "%Y"))
labels_time <- demprep:::make_labels_period_custom(year,
                                                   include_na = FALSE)
labels_age <- demprep:::make_labels_age(breaks = breaks_age,
                                        open_last = FALSE,
                                        include_na = FALSE)
demprep:::plot_date_to_age_triangle(date = date,
                                    dob = dob,
                                    unit = "year",
                                    breaks_time = breaks_time,
                                    breaks_age = breaks_age,
                                    labels_time = labels_time,
                                    labels_age = labels_age,
                                    show_vert = TRUE,
                                    show_diag = FALSE,
                                    show_months = FALSE)
text(x = date,
     y = age,
     labels = expression(italic(A), italic(B)),
     pos = 4)
```

## Labels for age groups, periods, and cohorts

Different produces of demographic data use many different schemes for labeling age groups, periods, and cohorts. **demprep** implements a system of labeling that tries to reflect common practices, while also being concise. The table below summarises the system. Dashes indicate combinations that are not allowed.

Table: **demprep** labels for age groups, periods, and cohorts

| Unit    | Type       | Age group   | Period        | Cohort         |
| :------ | :-------   | :---------: | :----------:  | :------------: |
| year    | single     | `"5"`       | `"2020"`      | `"2020"`       |
| year    | multiple   | `"5-9"`     | `"2025-2030"` | `"2025-2030"`  |
| year    | open left  | -           | -             | `"<2020"`      |
| year    | open right | `"100+"`    | -             | -              |
| quarter | single     | `"20"`      | `"2020 Q1"`   | `"2020 Q1"`    |
| quarter | multiple   | -           | -             | -              |
| quarter | open left  | -           | -             | `"<2020 Q1"`   |
| quarter | open right | `"400+"`    | -             | -              |
| month   | single     | `"60"`      | `"2020 Jan"`  | `"2020 Jan"`   |
| month   | multiple   | -           | -             | -              |
| month   | open left  | -           | -             | `"<2020 Jan"`  |
| month   | open right | `"1200+"`   | -             | -              |

**demprep** caters to three types of units: years, quarters, and months. Age intervals can be open on the right, such as the age group consisting of people aged 100 years or more. Cohorts can be open on the left, such as the cohort consisting of people born before January 2020. Multi-year intervals, such as ages 5 to 9 years, are allowed, but multi-quarter or multi-month intervals are not.

Reflecting standard practice, **demprep** treats  multi-year age groups and multi-year periods and cohorts differently. Labels for age groups refer to the last year of the current interval (eg the "9" in the 5-year age group "5-9"). Labels for periods and cohorts, in contrast, refer to the first year of the next interval (eg the "2030" in the 5-year period "2025-2030").

Standard period and cohort labels based on years, including the labels used in **demprep** are ambiguous. The first source of ambiguity is that labels based on years do not always start on the same day of the year. Periods and cohorts typically start on 1 January and end on 31 December. However, periods and cohorts that start on 1 July and end on 30 June are also common, and periods and cohorts that start on other dates, such as 1 April or 1 October, are also occasionally encountered. Labels such as "2015" or "2001-2006" do not distinguish between these various possibilities.

The second source of ambiguity is specific to one-year periods and cohorts. Some people label one-year periods and cohorts according to the calendar year at the start of the period or cohort, and others label it according to the calendar year at the end. For instance, some people label a year starting on 1 July 2020 and ending on 30 June 2021 as "2020" and others labels it as "2021". The year-at-start or year-at-end choice makes no difference if the period or cohort starts on 1 January and ends on 31 December, but for every other pair of start dates and end dates, it does make a difference. The table below, for instance, shows twenty-two different interpretations of "2020" (all assuming that the one-year periods start on the first day of the month.)

Table: Twenty-two interpretations of the period label "2020"

| Label uses start year | Label uses end year   |
|:----------------------:|:----------------------:|
| 1 Jan 2020 - 31 Dec 2020 | 1 Feb 2019 - 31 Jan 2020 |
| 1 Feb 2020 - 31 Jan 2021 | 1 Mar 2019 - 29 Feb 2020 |
| 1 Mar 2020 - 28 Feb 2021 | 1 Apr 2019 - 31 Mar 2020 |
| 1 Apr 2020 - 31 Mar 2021 | 1 May 2019 - 30 Apr 2020 |
| 1 May 2020 - 30 Apr 2021 | 1 Jun 2019 - 31 May 2020 |
| 1 Jun 2020 - 31 May 2021 | 1 Jul 2019 - 30 Jun 2020 |
| 1 Jul 2020 - 30 Jun 2021 | 1 Aug 2019 - 31 Jul 2020 |
| 1 Aug 2020 - 31 Jul 2021 | 1 Sep 2019 - 31 Aug 2020 |
| 1 Sep 2020 - 31 Aug 2021 | 1 Oct 2019 - 30 Sep 2020 |
| 1 Oct 2020 - 30 Sep 2021 | 1 Nov 2019 - 31 Oct 2020 |
| 1 Dec 2020 - 30 Nov 2021 | 1 Dec 2019 - 30 Nov 2020 |


# Functions in **demprep**

## Overview

**demprep** assumes that data preparation proceeds more-or-less as follows:

**0. Read in data and do initial tidying using non-demprep functions**

Use functions from base R or elsewhere to read the data into a data frame, put any date variables into a "year-month-day" format, and tidy variables not related to age, period, or cohort.

**1. Create or clean age, period, cohort, and triangle labels**

If the original data contains dates, then use functions such as `date_to_age_year` or `date_to_period_multi` to construct age, period, cohort, and triangle labels. If the original data already contains age, period, cohort, and triangle labels, then use functions such as `clean_age` to convert them to **demprep** formats.

**2. Ensure labels are consistent and complete**

Process any age, period, cohort, and Lexis triangle labels using functions such as `format_age_year` and `format_period_multi`, to make sure the labels are consistent and have all the required levels.

**3. Tabulate**

Use `dtabs` to turn the data into multidimensional arrays.


The inputs, outputs, and families of functions for steps 1 to 3 are as follows:

```{r, out.width = "70%", echo = FALSE}
include_graphics("workflow.png",
                 auto_pdf = TRUE)
```


## The `date_to` functions

### Overview

Suppose that we have some raw, individual-level data on dates of birth and dates of enrolment in a health care scheme,

```{r, echo = FALSE}
dates_df <- data.frame(date_of_birth = c("2000-03-07", "2010-12-25", "2007-02-28"),
                       date_of_enrolment = c("2002-08-12", "2014-01-31", "2015-07-01"))
dates_df		       
```

We want to calculate people's age at the time they enrolled, and the quarter in which they enrolled. We can do calculations, and others like them, using the `date_to` functions.


| Age groups            | Periods                  | Cohorts                  | Lexis triangles            |
| :-----------          | :----------------------- | :--------                | :------------------------- |
| `date_to_age_year`    | `date_to_period_year`    | `date_to_cohort_year`    | `date_to_triangle_year`    |
| `date_to_age_quarter` | `date_to_period_quarter` | `date_to_cohort_quarter` | `date_to_triangle_quarter` |
| `date_to_age_month`   | `date_to_period_month`   | `date_to_cohort_month`   | `date_to_triangle_month`   |

The `year`, `quarter`, and `month` suffixes in the function names describe the measurement units, so that, for example, `date_to_age_month` return's people's ages in months, and `date_to_cohort_year` returns people's year of birth.

To demonstrate the use of the `date_to` functions, we will be using the data frame `deaths`:

```{r}
deaths <- data.frame(name = c("Anwar", "Baptiste", "Candice"),
                     date_birth = c("2014-02-17", "2012-01-10", "2019-04-29"),
                     date_death = c("2019-10-11", "2020-02-27", "2020-08-01"))
deaths
```

Before running, we need to load packages **demprep** and (for the pipe `%>%` and various data manipulation functions) **dplyr**.

```{r}
library(demprep)
library(dplyr)
```

### Age

The `date_to_age` functions calculate ages denominated in years, quarters, and months.

```{r}
deaths %>%
  mutate(age_years = date_to_age_year(date = date_death,
                                      dob = date_birth),
         age_quarters = date_to_age_quarter(date = date_death,
                                            dob = date_birth),
         age_months = date_to_age_month(date = date_death,
                                        dob = date_birth))
```

Age is calculated using the approach discussed in Section 2.1, which looks at months and days-within-months attained, rather than absolute number of days. Thus, for example, a person born on 31 January 2001 turns one month old 29 days later, while a person born on 1 February 2001 turns on month old 28 days later.


### Periods

By default, `date_to_period_year` creates periods that start on 1 January,
```{r}
deaths %>%
  select(-date_birth) %>%
  mutate(year_start_jan = date_to_period_year(date = date_death))
```
which we might depict as
```{r, echo = FALSE, fig.height = 1.75}
demprep:::plot_date_to_period_year(date = deaths$date_death)
```

However, other start date are possible, provided that date is the first of the month,
```{r}
deaths %>%
  select(-date_birth) %>%
  mutate(year_start_apr = date_to_period_year(date = date_death,
	                                            month_start = "Apr"))
```
```{r, echo = FALSE, fig.height = 1.75}
demprep:::plot_date_to_period_year(date = deaths$date_death,
                                   month_start = "Apr")
```

As discussed in Section 2.3, some people base the labels of single-year periods on the calendar year at the start of the period, and others base them on the calendar year at the end. By default, `date_to_period_year` uses the calendar year on the first day of the period. Setting `label_year_start` to `FALSE` makes it use the calendar year on the last day.
```{r}
deaths %>%
  select(-date_birth) %>%
  mutate(year_label_start = date_to_period_year(date = date_death,
                                                month_start = "Apr"),
         year_label_end = date_to_period_year(date = date_death,
                                              month_start = "Apr",
                                              label_year_start = FALSE))
```

Labeling quarters and months is simpler. Function `date_to_period_quarter` implements a single set of start dates (1 January, 1 April, 1 July, and 1 October), and a single labeling style.
```{r}
deaths %>%
  select(-date_birth) %>%
  mutate(quarter = date_to_period_quarter(date_death))
```

`date_to_period_month` is similarly simple/inflexible.
```{r}
deaths %>%
  select(-date_birth) %>%
  mutate(month = date_to_period_month(date_death))
```


### Cohorts

The `date_to_cohort` functions behave exactly like their `date_to_period` equivalents. To obtain birth cohorts, for instance, we set `date` equal to date of birth.
```{r}
deaths %>%
  select(-date_death) %>%
  mutate(cohort = date_to_cohort_year(date = date_birth,
                                      month_start = "Apr",
                                      label_year_start = FALSE))
```

```{r, echo = FALSE, fig.height = 1.75}
demprep:::plot_date_to_cohort_year(date = deaths$date_birth)
```


### Lexis triangles

To calculate Lexis triangles, we need dates of events and dates of birth,
```{r}
deaths %>%
  mutate(triangle = date_to_triangle_year(date = date_death,
	                                        dob = date_birth))
```
```{r, echo = FALSE, fig.height = 6.5}
demprep:::plot_date_to_triangle_year(date = deaths$date_death,
                                     dob = deaths$date_birth)
```

Like `date_to_period_year`, and `date_to_cohort_year`, function `date_to_triangle_year`  has a `month_start` argument, which shifts the start date of the triangles.
```{r}
deaths %>%
  mutate(triangle = date_to_triangle_year(date = date_death,
	                                        dob = date_birth,
			                                    month_start = "Jul"))
```
```{r, echo = FALSE, fig.height = 6.5}
demprep:::plot_date_to_triangle_year(date = deaths$date_death,
                                     dob = deaths$date_birth,
                                     month_start = "Jul")
```



## The `clean` functions

Published demographic demographic is usually already aggregated into age groups, periods, or cohorts, rather than giving the original dates of events. In this case, when preparing data for use in the **dem** packages, the first task is to edit the labels for the age groups, periods, cohorts, so that they follow **dem** convetions. The functions for editing existing labels, and for checking these edits, are as follows:


| Age groups     | Periods           | Cohorts           | 
| :-----------   | :--------         | :--------         | 
| `clean_age`    | `clean_period`    | `clean_cohort`    | 
| `clean_age_df` | `clean_period_df` | `clean_cohort_df` | 
| `is_valid_age` | `is_vald_period`  | `is_valid_cohort` |

Functions `clean_age`, `clean_period`, and `clean_cohort` try to parse vectors of labels and convert the labels, where necessary, into **dem** formats. If they cannot parse a label, or if a label is already valid, then the functions leave the label untouched.


```{r}
x <- c("20 years", "80 and over", "young", "20-24")
clean_age(x)
```

Function `clean_age` treats labels consisting entirely of multiples of 5 specially,
```{r}
x <- seq(0, 60, 5)
x
clean_age(x)
```
And also labels that look like they come from a life table,
```{r}
x <- c(0, 1, seq(5, 80, 5))
x
clean_age(x)
```


Functions `clean_cohort` and `clean_period` give identical results, except for intervals that are open on the left, which `clean_cohort` parses and `clean_period` does not.

```{r}
x <- c("Q1 2020", "1922", "2010-2025", "before 2020")
clean_cohort(x)
clean_period(x)
```

It can sometimes be helpful to see what `clean_age`, `clean_period`, and `clean_cohort` have done, or will do. This is the purpose of functions `clean_age_df`, `clean_period_df`, and `clean_cohort_df`.

```{r}
x <- c("2021", "2022-2025", "2021", "q2 2020")
clean_period_df(x)
```

It can also be helpful to be able to check whether `clean_age`, `clean_period`, and `clean_cohort` have been able to parse the entire vector. This is what functions `is_valid_age`, `is_valid_period`, and `is_valid_cohort` do.

```{r}
x <- c("2021", "the 1960s", "1960-1970")
is_valid_period(x)
```
In a production system, some version of
```{r, eval = FALSE}
stopifnot(all(is_valid_period(x)))
```
is useful to catch any unexpected inputs.


## The `format` functions

### Overview

Demographic analyses usually require data to be arranged into age groups, periods, or cohorts, of standardised lengths, with all intermediate categories included. Tabulations should look like this

|   Age | 2020-2025 | 2025-2030 |
|-------+-----------+-----------|
|   0-4 |         1 |         3 |
|   5-9 |         4 |         8 |
| 10-14 |         0 |         3 |

rather than this

|   Age | 2020 | 2022-2023 | 2025-2030 |
|-------+------+-----------+-----------|
|   0-2 |    1 |         0 |         2 |
|     4 |    0 |         0 |         1 |
|   5-8 |    1 |         3 |         8 |
| 10-12 |    0 |         0 |         2 |
|    14 |    0 |         0 |         1 |.

The `format` functions take vectors of age, period, cohort, and Lexis triangle labels that conform to **dem** package conventions, and return factors where the intervals have standardised lengths, and where all intermediate categories, including ones that do not appear in the data, are included.

| Age groups           | Periods                 | Cohorts                 | Lexis triangles           |
| :-----------         | :--------               | :--------               | :----------------         |
| `format_age_year`    | `format_period_year`    | `format_cohort_year`    | `format_triangle_year`    |
| `format_age_multi`   | `format_period_multi`   | `format_cohort_multi`   | `format_triangle_multi`   |
| `format_age_custom`  | `format_period_custom`  | `format_cohort_custom`  | \<none\>                  |
| `format_age_lifetab` | \<none\>                | \<none\>                | \<none\>                  |
| `format_age_births`  | \<none\>                | \<none\>                | `format_triangle_births`  |
| `format_age_quarter` | `format_period_quarter` | `format_cohort_quarter` | `format_triangle_quarter` |
| `format_age_month`   | `format_period_month`   | `format_cohort_month`   | `format_triangle_month`   |

The last part of the function names describe the units that are returned. Functions `format_age_year`, `format_age_quarter`, and `format_age_month`, for instance, create labels where the intervals have lengths of one year, one quarter, and one month. Functions ending in `multi` return labels where then intervals can span multiple years, provided that the intervals all have the same length. Function `format_period_multi` can be used, for instance, to create labels for periods with widths of 5 years. `Functions ending in `custom` also  return labels where the intervals can span multiple years, but the intervals do not all have to be the same length. Function `format_age_lifetab` deals with age groups used in life tables, and  function `format_age_births` deals with age groups used for describing births.

When, for example, `format_age_multi` is supplied with a vector that uses single years of age, by default it converts these into 5-year age group labels: 
```{r}
original <- c(11, 93, 15, 30)
reformatted <- format_age_multi(original)
reformatted
```
The object holding the new 5-year labels is a factor. 
```{r}
class(reformatted)
```
A factor contain a "levels" attribute that lists all possible labels.
```{r}
levels(reformatted)
```
Tabulation functions such as `table`, `xtabs`, or `dtabs` (described below) make use of the levels.
```{r}
table(reformatted)
```
The tabulations include counts for all levels, including ones that do not appear in the data, which receive counts of zero. Including all levels is normally what we want when we are tabulating data for demographic analyses.

If we convert the factor into a character vector, the special behaviour is lost.
```{r}
table(as.character(reformatted))
```

Most of the `format` functions provide some control over the range of the labels. With `format_age_multi`, for instance, we can specify that the first age group starts at 10 rather than 0,
```{r}
format_age_multi(original, break_min = 10)
```

The `format` functions work on labels as well as numbers,
```{r}
x <- c("2020-2021", "2018", "2020-2025", "<2015")
format_cohort_multi(x)
```


### Age groups

Arguments `break_min`, `break_max`, and `open_last` can be used to control lower and upper limits of the age group labels. The default behavior for `format_age_year` and `format_age_multi`, for instance, is to create ordinary age groups between ages 0 and 100, and an open age group after that,
```{r}
x <- c("35-38", "50-54", "77")
format_age_multi(x, width = 10)
```
Alternative lower and upper limits can be specified via the `break_min` and `break_max` arguments,
```{r}
x <- c("35-38", "50-54", "77")
format_age_multi(x,
                 width = 10,
                 break_min = 20,
                 break_max = 90)
```
The open interval can be removed using the 'open_last' argument,
```{r}
x <- c("35-38", "50-54", "77")
format_age_multi(x,
                 width = 10,
                 break_min = 20,
                 break_max = 90,
                 open_last = FALSE)
```
Setting `break_min` and `break_max` to `NULL` allows the limits to be set by the data.
```{r}
x <- c("35-38", "50-54", "77")
format_age_multi(x,
                 width = 10,
		 break_min = NULL,
		 break_max = NULL)
```

When age groups with variable lengths are needed, function `format_age_custom` can be used. The age groups are defined via the `breaks` argument
```{r}
x <- c("35-38", "50-54", "77")
format_age_custom(x, breaks = c(15, 40, 80))
```

Function `format_age_lifetab` creates the special age groups needed for an "abridged" life table (ie a life table with age groups `"0"`, `"1-4"`, `"5-9"`, `"10-14"`, `"15-19"`, etc.
```{r}
x <- c("35-38", "50-54", "77")
format_age_lifetab(x)
```

The other specialsed `format_age` function is `format_age_biths`, which creates age groups for birth rates or counts,
```{r}
x <- c("22", "30-33", "18", "40-44")
format_age_births(x)
```
Function `format_age_biths` can recode values that fall outside the expected range,
```{r}
x <- c("10", "30-33")
format_age_births(x, recode_up = TRUE)
```

### Periods

The `format_period` functions, in contrast to the `format_age` functions do not have `break_min` and `break_max` arguments. Instead, the range of the labels is set by the data (like what happens with the `format_age` functions when `break_min` and `break_max` are set to `NULL`.)

The ambiguities of single-year period labels mean that functions `format_period_multi` and `format_period_custom` need extra information to parse these labels and align them to other labels. By default, `format_period_multi` and `format_period_custom` treats single-year periods as beginning in January. Under the default settings, the label `"2050"` refers to the period between 1 January 2050 and 31 December 2050, the label `"2050-2055"` refers the period between 1 January 2050 and 31 December 2054, and the first period falls within the second.
```{r}
x <- c("2050", "2050-2055")
format_period_multi(x)
```
However, if we set `month_start` to `"July"' and `label_year_start` to `FALSE`, then `"2050"` refers to the period between 1 July 2049 and 30 June 2050,  `"2050-2055"` refers to the period between 1 July 2050 and 31 June 2055, and the first period falls outside the second.
```{r}
x <- c("2050", "2050-2055")
format_period_multi(x,
                    month_start = "July",
		    label_year_start = FALSE)
```

Multi-year periods that start on, say, 2021 rather than 2020, can be obtained by changing the `origin` argument from its default value of 2000. The absolute value of `origin` does not in fact matter - only the remainder when it is divided by `width`.

```{r}
x <- c("2020", "2021", "2027-2028")
format_period_multi(x)
format_period_multi(x, origin = 2021)
```


### Cohorts

The `format_cohort` functions work exactly like the equivalent `format_period` functions, except that the `format_cohort` functions allow for the possibility of an interval that is open on the left.
```{r}
x <- c("2003", "1998", "2015", "1984", "2002")
format_cohort_year(x)
format_cohort_year(x, break_min = 1990)
```
A birth cohort with no lower limit is equivalent to an age group with no upper limit. On 31 December 2019, for instance, the cohort `"<1920" is equivalent to the age group 100+. 


### Lexis triangles

The `format_triangle` functions produce Lexis triangles that have consistent lengths. To aggregate triangles, the `format_triangle` functions need information on age, and, in the case of `format_triangle_multi` and `format_triangle_births`, detailed information on periods.
```{r}
x <- c("Lower", "Upper", "Lower")
age <- c("22", "56", "103")
format_triangle_year(x = x, age = age)
```



## The `dtabs` functions

### The `dtabs` function for ordinary tabulation

xtabs for tabulation, but nice formula-based way of turning general data frame into array.

Once all the variables have been put into the required formats, we can tabulate the data. The most powerful tabulation function in base R is `xtabs`.  **demprep** contains a modified version of `xtabs` called `dtabs`. `dtabs` is designed to be simpler and safer than `xtabs`, particularly for constructing demographic arrays. The differences between `xtabs` and `dtabs` are 

|                                        | `xtabs`         | `dtabs`         |
|----------------------------------------+-----------------+-----------------|
| Position of `data` argument            | first           | second          |
| Suppress `NA` in classifying variables | yes             | no              |
| Suppress `NA` in response variable     | by default, yes | by default, no  |
| Combinations not in data               | always 0        | can be 0, NA    |
| `subset` argument                      | yes             | no              |
| Drop unused levels                     | sometimes       | never           |

Using a pipe (`%>%` or `|>`) is slightly easier when the `data` argument comes first than when it comes second. In `xtabs` the `data` argument comes second,
```{r}
df <- data.frame(y = c(1, 2, 1),
                 x = c("a", "b", "b"))
df %>%
  xtabs(y ~ x, .) # need '.' as placeholder for data
```

In `dtabs`, the `data` argument comes first,
```{r}
df %>%
  dtabs(y ~ x)
```

When an `NA` appears in a cross-classifying variable, `xtabs` by default silently suppresses it,
```{r}
df <- data.frame(y = c(1, 2, 1),
                 x = c("a", "b", NA))
df %>%
  xtabs(y ~ x, .)
```

`dtabs`, in contrast, treats the `NA` as an extra level,
```{r}
df <- data.frame(y = c(1, 2, 1),
                 x = c("a", "b", NA))
df %>%
  dtabs(y ~ x)
```

Similarly, when an `NA` appears in the response variable, `xtabs` silently suppresses it
```{r}
df <- data.frame(y = c(1, 2, NA),
                 x = c("a", "b", "a"))
df %>%
  xtabs(y ~ x, .)
```

`dtabs`, in contrast, defaults to keeping the `NA`,
```{r}
df <- data.frame(y = c(1, 2, NA),
                 x = c("a", "b", "a"))
df %>%
  dtabs(y ~ x)
```
(though the `NA` can be dropped by setting `na_rm` to `TRUE`.)

The reason for forcing users to explicitly deal with `NA`s is that treatment of `NA`s is an important methodological that deserves the user's attention.  "Complete case analyses", where `NA`s are simply dropped from the data, can be seriously misleading (see, for instance, Little's and Rubin's book *Statistical analysis with missing data*.)

Another important difference between `xtabs` and `dtabs` is the way that the two functions handle combinations of cross-classifying variables that do not appear in the data. `xtabs` always gives missing combinations a value of 0. For instance, when a dataset has no one who is aged 5-9 years and also male, then it assigns a 0 to this combination,
```{r}
df <- data.frame(y = c(1, 2, 3),
                 age = c("0-4", "5-9", "0-4"),
                 sex = c("Female", "Female", "Male"))
df %>%
  xtabs(y ~ age + sex, .)
```
This is the correct behaviour when using `xtabs` for iss original purpose, which to tabulate counts. But it is not when we want if we are using `xtabs` to convert a data frame of non-count values into an array. In the following example, `0` is *not* a sensible value for the missing combination.
```{r}
df <- data.frame(y = c(33.3, -4.1, 22.9),
                 age = c("0-4", "5-9", "0-4"),
                 sex = c("Female", "Female", "Male"))
df %>%
  xtabs(y ~ age + sex, .)
```

`dtabs` allows users specify the value that is used for combinations of variables that do not appear in the data. The value is specified via the `fill` argument,
```{r}
df <- data.frame(y = c(33.3, -4.1, 22.9),
                 age = c("0-4", "5-9", "0-4"),
                 sex = c("Female", "Female", "Male"))
df %>%
  dtabs(y ~ age + sex, fill = NA)
```

If no value for `fill` is supplied, then `xtabs` will try to infer the correct value. If there is no response variable, or if the response variable consists entirely of positive integers, then `dtabs` assumes that the data consists of counts, and sets `fill` to `0`. If the response variable has one or more zeros or negative numbers, then `dtabs` assumes the response variable is not counts, and sets `fill` to `NA`. If neither of these conditions are met, then `dtabs` throws an error.

A final difference between `xtabs` and `dtabs` is that `xtabs` allows the user to take subsets of the data, or drop unused levels from factors, as part of the tabulation while `dtabs` does not. Limiting the options in `dtabs` makes the function easier to understand. It also forces the users to write seperate calls to funtions such as `subset` or `droplevels`, which makes the code easier to understand.


### The `dtabs_survey` function for the tabulation of survey data on binary outcomes

**demprep** has a specialised version of `dtabs`, called `dtabs_survey` for tabulating survey data on binary (yes-no) outcomes. `dtabs_survey` calculates "effective" numbers of trials and successes that allow data from a complex survey to be analysed as if it came from a simple random survey. Doing so sacrifices some accuracy in return for a large increase in convenience.

## Other functions

### Imputing dates

Sometimes input data has incomplete data on dates, such as having the year and month of births but not the days. One way of dealing with incomplete data is to impute the missing information. This is what functions `impute_date` and `impute_dob` are for.

The imputation is random, so, for repeatability, we set the random seed. 
```{r}
set.seed(0)
```

In our first example, we know the year and month of some events, but not the day, so we use `impute date`.
```{r}
impute_date(year = c(2000, 2005, 2003),
            month = c("Feb", "Nov", "Apr"))
```

In our second example, we know the dates of events, and we know people's age in years at the time of the eevents, and we want to impute dates of birth.
```{r}
impute_dob(date = c("2021-03-23", "2021-02-13", "2020-04-25"),
           age_years = c(3, 1, 0))
```


### Labels based on date rates

The ambiguities of period and cohort labels do not normally cause any problems when working with a single dataset. When working with multiple datasets, however, aligning periods correctly can be confusing and error-prone.

The functions

|                    |
|--------------------|
| `as_date_range_year` |
| `as_date_range_multi` |
| `as_date_range_custom` |
| `as_date_range_quarter` |
| `as_date_range_month` |

convert from standared period and cohort labels to nonstandard but unambiguous ones that use explicit dates.

By default, `month_start` is set to `"Jan"` and `label_year_start` is set to `TRUE`
```{r}
x <- c("2022", "2028")
as_date_range_year(x)
```
Different settings give different interpretations of the same labels,
```{r}
x <- c("2022", "2028")
as_date_range_year(x, 
                   month_start = "Mar",
                   label_year_start = FALSE)
```


### Flipping year labels




# Examples


```{r}
set.seed(0)
```


## Counts of deaths in New Zealand

```{r}
deaths <- demprep::nzdeaths
deaths %>%
  sample_n(5)
```

```{r}
unique(deaths$age)
```

```{r}
deaths <- deaths %>%
  filter(age != "Total all ages") %>%
  mutate(age = clean_age(age))
unique(deaths$age)
```

```{r}
deaths <- deaths %>%
  mutate(age = format_age_multi(age, width = 10))
unique(deaths$age)
```


```{r}
deaths <- deaths %>%
  mutate(year = flip_year_label(year))
unique(deaths$year)
```

```{r}
deaths <- deaths %>%
  dtabs(count ~ age + sex + year)
deaths
```



## Counts of births in Iceland

Births in the calendary years 1981 to 2019. Want array of birth by period of birth, age of father, Lexis triangle of father. Five-year age groups and periods. Start in 1981.


```{r}
births <- demprep::icebirths
births %>%
  sample_n(5)
```

```{r}
births <- births %>%
  mutate(period1 = date_to_period_year(dob_child))
births %>%
  sample_n(5)
```


```{r}
births <- births %>%
  mutate(age1 = date_to_age_year(date = dob_child,
                                 dob = dob_father))
births %>%
  sample_n(5)
```

```{r}
births <- births %>%
  mutate(triangle1 = date_to_triangle_year(date = dob_child,
                                           dob = dob_father))
births %>%
  sample_n(5)
```


```{r}
births <- births %>%
  mutate(period = format_period_multi(period1,
                                      origin = 1981))
births %>% 
  sample_n(5)
```


```{r}
births <- births %>%
  mutate(age = format_age_births(x = age1, 
                                 width = 5,
                                 break_min = 15,
                                 break_max = NULL,
                                 recode_up = TRUE))
births %>% 
  sample_n(5)
```


```{r}
births <- births %>%
  mutate(triangle = format_triangle_multi(triangle1,
                                          age = age1,
                                          period = period1,
                                          origin = 1981))
births %>% 
  sample_n(10)
```
```{r}
births %>%
  filter(triangle != triangle1) %>%
  sample_n(5)
```


```{r}
births_array <- births %>%
  filter(period != "2016-2021") %>%
  dtabs(~ age + triangle + period)
dimnames(births_array)
births_array
```

## An example involving rates

