
#' Cross-tabulation with weighted survey data
#'
#' Tabulate binary outcomes, for combinations of
#' cross-classifying variables, from individual-level
#' survey data. The survey is assumed to have a complex
#' design, involving techniques such as clustering
#' and stratification. The complex design implies
#' that different members
#' of the target population have different probabilities
#' of being included in the survey. These differential
#' inclusion probabilities complicate subsequent analyses,
#' including the calculation of means and variances.
#' However, by exploiting information contained in the survey
#' weights, it is possible to calculate the "effective"
#' number of trials and successes for each
#' combination of the cross-classifying variables.
#' These effective numbers can be analysed as if
#' they were generated by simple random sampling.
#' The ratio of the actual
#' number of trials to the effective number
#' is known as the design effect. The method that
#' \code{dtab_survey} uses for calculating
#' design effects implies that they are always
#' greater than or equal to one.
#'
#' The right hand side of the \code{formula} argument
#' should list the cross-classifying
#' variables, separated by \code{+} signs. The left hand side
#' should give the response variable. This variable must be
#' a binary outcome: a mixture of \code{1}s and \code{0}s
#' or a mixture of \code{TRUE}s and \code{FALSE}s.
#' A dot on the right hand side
#' is shorthand for "all variables not included
#' on the left hand side".
#'
#' The \code{weights} vector is typically a column
#' within \code{data}. It should consist entirely
#' of non-negative values. If a record has a weight
#' of 0, the record is removed from the dataset
#' before the calculations are made.
#'
#' Following Ghitza and Gelman (2013), effective
#' numbers of trials and successes are calculated as
#' follows:
#' \enumerate{
#'   \item Calculate design effect. This is proportional
#'     to the variance of the weights within each
#'     cell of the tabulation. An overall design
#'     effect is calculated by taking the median of
#'     the cell-level design effects.
#'   \item Calculate effective number of trials.
#'     The effective number of trials within each
#'     cell is calculated by dividing the (unweighted) number of
#'     responses in each cell by the overall design effect.
#'   \item Calculate weighted proportion of successes in
#'     each cell. The proportion of successes is calculated
#'     by taking the weighted mean of the outcome variable,
#'     with the weights equal to the survey weights.
#'   \item Calculate effective number of succcesses.
#'     Multiply the weighted proportion of successes in each
#'     cell by the effective number of trials in that
#'     cell.
#' }
#'
#' The effective numbers of success and trials obtained
#' in this way will not generally be integers. To
#' perform further calculations on these data it may
#' be necessary to \code{\link{round}} them.
#'
#' Ghitza and Gelman (2013) in fact calcuate the overall
#' design effect by taking the mean, rather than
#' the median, of the cell-level design effects.
#' The mean is, however, sensitive to outliers, as
#' can occur when cells have few observations.
#' The original method can be obtained by setting
#' the \code{FUN} argument to \code{\link[base]{mean}}
#' rather than \code{\link[stats]{median}}.
#'
#' If there are no observations for a particular
#' combination of the cross-classifying variables,
#' then the corresponding cell is not included in the
#' calculation of design effects, and the number of
#' effective trials and successes for that cell
#' are set to 0. If there is one observation for a particular
#' combination of the cross-classifying variables,
#' then a design effect for that cell cannot be calculated,
#' and the cell is ignored in the calculation of the overall
#' design effect. However, estimates of the effective
#' number of trials and successes for that cell are provided.
#' 
#' @inheritParams dtabs
#' @param formula A \code{\link[stats]{formula}}.
#' The formula must contain a response, and that
#' response must be a binary varibale.
#' @param weights A vector of weights. Required.
#' @param FUN The function used to calculate
#' the overall design effect from cell-level
#' design effects. Defaults to \code{median}.
#'
#' @return A named list of two arrays.
#'
#' @seealso \code{dtabs_survey} is a modified version of function
#' \code{\link{dtabs}}, which is designed for unweighted data,
#' such as administrative or census data, or
#' for aggregate-level data. \code{dtabs} is in turn
#' based on function \code{\link[stats]{xtabs}}.
#'
#' @source Ghitza Y and Gelman A. 2013. Deep interactions with MRP:
#' Election turnout and voting patterns among small electoral subgroups.
#' \emph{American Journal of Political Science}, 57(3): 762-776.
#'
#' For an alternative way of calculating effective
#' numbers of responses, see Chen C, Wakefield J, and Lumley T.
#' 2014. The use of sampling weights
#' in Bayesian hierarchical models for small area estimation.
#' \emph{Spatial and Spatio-temporal Epidemiology}. 11: 33-43.
#'
#' @examples
#' ## create a small synthetic dataset
#' df <- data.frame(is_obese = rbinom(n = 25,
#'                                    size = 1,
#'                                    prob = 0.3),
#'                  age = sample(c("10-14", "15-19", "20-24"),
#'                               size = 25,
#'                               replace = TRUE),
#'                  sex = sample(c("F", "M"),
#'                               size = 25,
#'                               replace = TRUE),
#'                  wt = runif(n = 25,
#'                             min = 5,
#'                             max = 40))
#'
#' ## obtain tabulations
#' dtabs_survey(df, is_obese ~ age + sex, weights = wt)
#'
#' ## just for comparison, obtain tabulations without
#' ## accounting for survey design
#' dtabs(df, is_obese ~ age + sex)
#' @export
dtabs_survey <- function (data = parent.frame(),
                          formula,
                          weights,
                          na_rm = FALSE,
                          FUN = stats::median) {
    ## check and tidy inputs
    formula <- stats::as.formula(formula)
    if (!inherits(formula, "formula")) 
        stop(gettextf("'%s' missing or incorrect",
                      "formula"),
             call. = FALSE)
    if (length(formula) < 3L)
        stop(gettextf("formula '%s' does not have a response",
                      paste(deparse(formula), collapse = " ")),
             call. = FALSE)
    if (any(attr(stats::terms(formula, data = data), "order") > 1L)) 
        stop(gettextf("formula '%s' has interactions",
                      paste(deparse(formula), collapse = " ")),
             call. = FALSE)
    if (missing(weights))
        stop(gettextf("argument '%s' is missing with no default",
                      "weights"),
             call. = FALSE)
    demcheck::err_is_logical_flag(x = na_rm,
                                  name = "na_rm")
    call <- match.call()
    if (is.matrix(eval(call$data, parent.frame()))) 
        call$data <- as.data.frame(data)
    ## create model frame
    call$na.action  <- quote(na.pass)
    i_args <- match(c("formula", "data", "weights", "na.action"), names(call))
    call <- call[c(1L, i_args)]
    call[[1L]] <- quote(stats::model.frame)
    model_frame <- eval(call, parent.frame())
    ## check weights
    i_wt <- match("(weights)", names(model_frame))
    wt <- model_frame[[i_wt]]
    demcheck::err_not_na_vector(x = wt,
                                name = "weights")
    demcheck::err_non_negative_vector(x = wt,
                                      name = "weights")
    if (all(wt == 0L))
        stop(gettextf("'%s' all zero",
                      "weights"))
    ## check response
    i_response <- attr(attr(model_frame, "terms"), "response")
    response <- model_frame[[i_response]]
    nc <- NCOL(response)
    if (nc > 1L)
        stop(gettextf("response has %d columns",
                      nc),
             call. = FALSE)
    if (!(is.logical(response) || all(response %in% c(0L, 1L, NA))))
        stop(gettextf("response contains values other than %s and %s or %d and %d",
                      "TRUE", "FALSE", 1L, 0L),
             call. = FALSE)
    ## calculations
    INDEX <- model_frame[-c(i_response, i_wt)]
    not_fac <- !vapply(INDEX, is.factor, TRUE)
    INDEX[not_fac] <- lapply(INDEX[not_fac], factor)
    response <- response[wt > 0L]
    INDEX <- INDEX[wt > 0L, , drop = FALSE]
    wt <- wt[wt > 0L]
    weights_identical <- length(wt) == 1L || all(wt[-1L] == wt[[1L]])
    ones <- rep(1L, times = nrow(INDEX))
    trials_unweighted <- tapply(X = ones,
                                INDEX = INDEX,
                                FUN = sum,
                                na.rm = FALSE,
                                default = 0L,
                                simplify = TRUE)
    if (weights_identical) {
        successes_unweighted <- tapply(X = response,
                                       INDEX = INDEX,
                                       FUN = sum,
                                       na.rm = na_rm,
                                       default = NA,
                                       simplify = TRUE)
        ans <- list(successes = successes_unweighted,
                    trials = trials_unweighted)
    }
    else {
        if (all(trials_unweighted <= 1L))
            stop(gettext("no cells have 2 or more observations, so no design effects can be calculated"),
                 call. = FALSE)
        successes_weighted <- tapply(X = response * wt,
                                     INDEX = INDEX,
                                     FUN = sum,
                                     na.rm = na_rm,
                                     default = NA,
                                     simplify = TRUE)
        trials_weighted <- tapply(X = wt,
                                  INDEX = INDEX,
                                  FUN = sum,
                                  na.rm = FALSE,
                                  default = NA,
                                  simplify = TRUE)
        mean_weights <- tapply(X = wt,
                               INDEX = INDEX,
                               FUN = mean,
                               na.rm = FALSE,
                               default = NA,
                               simplify = TRUE)
        sd_weights <- tapply(X = wt,
                             INDEX = INDEX,
                             FUN = stats::sd,
                             na.rm = FALSE,
                             default = NA,
                             simplify = TRUE)
        if (all(sd_weights == 0))
            mean_design_effect <- 1L
        else {
            design_effect <- 1 + (sd_weights / mean_weights)^2
            design_effect <- design_effect[trials_unweighted >= 2L]
            overall_design_effect <- FUN(design_effect, na.rm = TRUE)
        }
        trials_effective <- trials_unweighted / overall_design_effect
        propn_weighted <- successes_weighted / trials_weighted
        successes_effective <- propn_weighted * trials_effective
        no_obs <- trials_unweighted == 0L
        successes_effective[no_obs] <- 0L
        trials_effective[no_obs] <- 0L
        ans <- list(successes = successes_effective,
                    trials = trials_effective)
    }
    ans
}





    
